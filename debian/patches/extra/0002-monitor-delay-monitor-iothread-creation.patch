From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Wolfgang Bumiller <w.bumiller@proxmox.com>
Date: Tue, 25 Sep 2018 10:15:07 +0200
Subject: [PATCH] monitor: delay monitor iothread creation

Commit d32749deb615 moved the call to monitor_init_globals()
to before os_daemonize(), making it an unsuitable place to
spawn the monitor iothread as it won't be inherited over the
fork() in os_daemonize().

We now spawn the thread the first time we instantiate a
monitor which actually has use_io_thread == true.
Instantiation of monitors happens only after os_daemonize().
We still need to create the qmp_dispatcher_bh when not using
iothreads, so this now still happens in
monitor_init_globals().

Signed-off-by: Wolfgang Bumiller <w.bumiller@proxmox.com>
Fixes: d32749deb615 ("monitor: move init global earlier")
Message-Id: <20180925081507.11873-3-w.bumiller@proxmox.com>
Reviewed-by: Eric Blake <eblake@redhat.com>
Reviewed-by: Peter Xu <peterx@redhat.com>
Tested-by: Peter Xu <peterx@redhat.com>
[This fixes a crash on shutdown with --daemonize]
Signed-off-by: Markus Armbruster <armbru@redhat.com>
---
 monitor.c | 36 ++++++++++++++++++++++--------------
 1 file changed, 22 insertions(+), 14 deletions(-)

diff --git a/monitor.c b/monitor.c
index 836c0bbdaa..c7eae64fd9 100644
--- a/monitor.c
+++ b/monitor.c
@@ -807,9 +807,14 @@ static void monitor_qapi_event_init(void)
 
 static void handle_hmp_command(Monitor *mon, const char *cmdline);
 
+static void monitor_iothread_init(void);
+
 static void monitor_data_init(Monitor *mon, bool skip_flush,
                               bool use_io_thread)
 {
+    if (use_io_thread && !mon_iothread) {
+        monitor_iothread_init();
+    }
     memset(mon, 0, sizeof(Monitor));
     qemu_mutex_init(&mon->mon_lock);
     qemu_mutex_init(&mon->qmp.qmp_queue_lock);
@@ -4544,6 +4549,15 @@ static AioContext *monitor_get_aio_context(void)
 static void monitor_iothread_init(void)
 {
     mon_iothread = iothread_create("mon_iothread", &error_abort);
+}
+
+void monitor_init_globals(void)
+{
+    monitor_init_qmp_commands();
+    monitor_qapi_event_init();
+    sortcmdlist();
+    qemu_mutex_init(&monitor_lock);
+    qemu_mutex_init(&mon_fdsets_lock);
 
     /*
      * The dispatcher BH must run in the main loop thread, since we
@@ -4559,21 +4573,11 @@ static void monitor_iothread_init(void)
      * monitors that are using the I/O thread have their output
      * written by the I/O thread.
      */
-    qmp_respond_bh = aio_bh_new(monitor_get_aio_context(),
+    qmp_respond_bh = aio_bh_new(iohandler_get_aio_context(),
                                 monitor_qmp_bh_responder,
                                 NULL);
 }
 
-void monitor_init_globals(void)
-{
-    monitor_init_qmp_commands();
-    monitor_qapi_event_init();
-    sortcmdlist();
-    qemu_mutex_init(&monitor_lock);
-    qemu_mutex_init(&mon_fdsets_lock);
-    monitor_iothread_init();
-}
-
 /* These functions just adapt the readline interface in a typesafe way.  We
  * could cast function pointers but that discards compiler checks.
  */
@@ -4711,7 +4715,9 @@ void monitor_cleanup(void)
      * we need to unregister from chardev below in
      * monitor_data_destroy(), and chardev is not thread-safe yet
      */
-    iothread_stop(mon_iothread);
+    if (mon_iothread) {
+        iothread_stop(mon_iothread);
+    }
 
     /*
      * Flush all response queues.  Note that even after this flush,
@@ -4735,8 +4741,10 @@ void monitor_cleanup(void)
     qemu_bh_delete(qmp_respond_bh);
     qmp_respond_bh = NULL;
 
-    iothread_destroy(mon_iothread);
-    mon_iothread = NULL;
+    if (mon_iothread) {
+        iothread_destroy(mon_iothread);
+        mon_iothread = NULL;
+    }
 }
 
 QemuOptsList qemu_mon_opts = {
-- 
2.11.0

