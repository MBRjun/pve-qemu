From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Wolfgang Bumiller <w.bumiller@proxmox.com>
Date: Fri, 7 Sep 2018 14:45:51 +0200
Subject: [PATCH] monitor: create iothread after daemonizing

Commit d32749deb615 moved the call to monitor_init_globals()
to before os_daemonize() in order to initialize locks used
when parsing arguments and instantiating monitors.
This function also creates an iothread which is now lost
when fork()ing in os_daemonize(), causing its final join to
fail.
Fix this by exposing monitor_iothread_init() to be used in
vl.c after the os_daemonize() call.

FIXME: verify nothing between the new init() place and
iothread spawning actually already depends on the iothread.

Signed-off-by: Wolfgang Bumiller <w.bumiller@proxmox.com>
Fixes: d32749deb615 ("monitor: move init global earlier")
---
 include/monitor/monitor.h | 1 +
 monitor.c                 | 3 +--
 vl.c                      | 1 +
 3 files changed, 3 insertions(+), 2 deletions(-)

diff --git a/include/monitor/monitor.h b/include/monitor/monitor.h
index 2ef5e04b37..119c4a393e 100644
--- a/include/monitor/monitor.h
+++ b/include/monitor/monitor.h
@@ -18,6 +18,7 @@ extern __thread Monitor *cur_mon;
 bool monitor_cur_is_qmp(void);
 
 void monitor_init_globals(void);
+void monitor_iothread_init(void);
 void monitor_init(Chardev *chr, int flags);
 void monitor_cleanup(void);
 
diff --git a/monitor.c b/monitor.c
index 77861e96af..24bfa0266b 100644
--- a/monitor.c
+++ b/monitor.c
@@ -4539,7 +4539,7 @@ static AioContext *monitor_get_aio_context(void)
     return iothread_get_aio_context(mon_iothread);
 }
 
-static void monitor_iothread_init(void)
+void monitor_iothread_init(void)
 {
     mon_iothread = iothread_create("mon_iothread", &error_abort);
 
@@ -4569,7 +4569,6 @@ void monitor_init_globals(void)
     sortcmdlist();
     qemu_mutex_init(&monitor_lock);
     qemu_mutex_init(&mon_fdsets_lock);
-    monitor_iothread_init();
 }
 
 /* These functions just adapt the readline interface in a typesafe way.  We
diff --git a/vl.c b/vl.c
index a03e4c2867..d96f4d0d2a 100644
--- a/vl.c
+++ b/vl.c
@@ -4008,6 +4008,7 @@ int main(int argc, char **argv, char **envp)
 
     os_daemonize();
     rcu_disable_atfork();
+    monitor_iothread_init();
 
     if (pid_file && qemu_create_pidfile(pid_file) != 0) {
         error_report("could not acquire pid file: %s", strerror(errno));
-- 
2.11.0

